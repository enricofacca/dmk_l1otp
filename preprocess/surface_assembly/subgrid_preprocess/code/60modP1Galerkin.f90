module P1GalerkinSurface
  use Globals
  use GeometrySurface
  implicit none  
  private
  !>--------------------------------------------------------------------------
  !> Structure variable conating data of P1-Galerkin basis function
  !> given a surface triangualtion mesh $\Tau_h(\Omega)$ 
  !> with nnode nodes ( in R^3) and ncell triangles. 
  !> $P1(\Tau_h)$ is the finite-dimensional generated by linear combination
  !> of the function $(Psi_{i})_{i=1,nnode}$ such that
  !> $\Psi_i{x_j,y_j,z_j}=\delta_{i,j}$ for all node,
  !> and is denoted by $P1_{h}$.
  !> Example function in $P1_{h}$ is 
  !> $\PotH(x,y)=\sum_{i}^{nnode}u_i\Psi_{i}(x,y,z)$.
  !>--------------------------------------------------------------------------
  type, public :: p1gal
     !> Number of basis functions
     integer :: nbase
     !> Number of cells 
     integer :: ncell 
     !> Tetrahedrons used 
     type(mesh), pointer :: grid
     !> Number of term for ssr (Symmetric  Sparse by Row)
     integer :: nterm_ssr = 0  
     !> Number of term for csr (Compressed Sparse by Row)
     integer :: nterm_csr = 0
     !> Dimension (grid%nnode+1)
     !> Pointer for diagonal term of ssr matrix 
     integer, allocatable :: ia_ssr(:)
     !> Dimension (nterm_ssr)
     !> Pointer for column index of ssr matrix
     integer, allocatable :: ja_ssr(:)
     !> Dimension (4,4,ncell)
     !> Pointer assembler_ssr for ssr matrix
     integer, allocatable :: assembler_ssr(:,:,:)
     !> Dimension (grid%nbase+1)
     !> Pointer for diagonal term of csr matrix
     integer, allocatable :: ia_csr(:)
     !> Dimension (nterm_ssr)
     !> Pointer for column index of sparse symmetric matrixes
     integer, allocatable :: ja_csr(:)
     !> Dimension (4,4,ncell)
     !> Pointer assembler_ssr for sparse symmetric matrixes
     integer, allocatable :: assembler_csr(:,:,:)
     !> Dimension (3,3,ncell)
     !> Coefficients of the basis functions 'a + b*x + c*y+ d*z' 
     !> over the triangles. 
     !> Each column corresponds to 
     !> node  1    2    3   
     !> a  ( a1   a2   a3   ) 
     !> b  ( b1_x b2_x b3_x )
     !> c  ( c1_y c2_y c3_y )
     !> d  ( d1_z d2_z d3_z )
     !> the node of mesh%topol
     !> Calculated in the constructor
     real(kind=double), allocatable :: base_coeff(:,:,:)
     !> Dimension (3,3,ncell)
     !> Projection of gradient of the local base functions
     !> On the triangle
     !> loc. index node  1          2          3  
     !> dx  (    dx(\Psi_1) dx(\Psi_2) dx(\Psi_3) )
     !> dy  (    dy(\Psi_1) dy(\Psi_2) dy(\Psi_3) )
     !> dz  (    dz(\Psi_1) dz(\Psi_2) dz(\Psi_3) )
     !> the node of mesh%topol
     !> Calculated in the constructor
     real(kind=double), allocatable :: grad_projected(:,:,:)
     !> Dimension (grid%nnode)
     !> Integral of the basis function
     !> Calculated in the constructor
     real(kind=double), allocatable :: integral_fun(:)
   contains
     !> static constructor
     !> (procedure public for type p1gal)
     procedure, public, pass :: init => init_p1gal
     !> static destructor
     !> (procedure public for type p1gal)
     procedure, public, pass :: kill => kill_p1gal
     !> Info procedure.
     !> (public procedure for type mesh)
     procedure, public, pass :: info => write_p1gal
     !> constructor of the coeff array of stiffness
     !> with scalar conductivity coefficient
     !> (procedure public for type p1)
     procedure, public, pass :: build_stiff
     !> Compute the integral of piecewise constant
     !> functions defined on the grid or super grid
     !> (procedure public for type p1)
     procedure, public, pass :: int_test
     !> Compute the rhs of elliptic system 
     !> for given forcing e neumann term 
     !> (procedure public for type p1)
     procedure, public, pass :: build_rhs_forcing
     !> evaluation of the gradient $\nabla u_h$
     !> (procedure public for building real array grad_x,grad_y)
     procedure, public, pass :: eval_grad
     !> Evaluation of the gradient $\nabla u_h$ retricted
     !> to a given cell
     !> (procedure public for building real array grad)
     procedure, public, pass :: eval_gradcell
     !> evaluation of the euclidean norm of the gradient over a tetrahedron
     !> $|\nabla u_h$|$ 
     !> (procedure public for building real array nrm_grad)
     procedure, public, pass :: eval_nrm_grad
     !> Procedure to get  the gradient of the base functions
     !> realtive to a node for a given cell
     !> (procedure public for building real array grad)
     procedure, public, pass :: get_gradbase
     !> Procedure for the construction of the nodes permutation 
     !> that minimize bandwidth for P1 Galerkin
     !> It finds the reverse Cuthill-Mckee ordering 
     !> for adjacency matrix
     !>(procedure public for type p1gal)
     procedure, public, pass :: genrcm
     !>--------------------------------------------------------------------
     !> Private Procedures (used in init)
     !>--------------------------------------------------------------------
     !> construction of the coefficients of the P1-basis function
     !> (procedure private for type p1gal member 
     !> base_coeff initializated in the procedure. Used in init)
     procedure, private, pass :: build_coeff
     !> Constructor of area_basis array. 
     !> (procedure private for type p1gal member area_basis. Used in init)
     procedure, private, pass :: build_integral_fun
     !> Builds the pointer ia_ssr, ja_ssr for symmetric sparse matrix
     !> (procedure private for type p1gal. Used in init)
     procedure, private, pass :: build_iaja_ssr
     !> construction of the hyper-pointer assembler_ssr for sym. sparse matix
     !> (procedure private for integer array: assembler_ssr
     !> initialized in the procedure. Used in init)
     procedure, private, nopass :: build_assembler_ssr
     !> Builds the pointer ia_csr, ja_csr 
     !> (procedure private for type p1gal. Used in init)
     procedure, private, pass :: build_iaja_csr
     !> Procedure for the construction 
     !> of the hyper-matrix assembler for sparse matrix
     !> in csr format
     !> (procedure private for integer array: assembler
     !> initialized in the procedure. Used in init)
     procedure, private, nopass :: build_assembler_csr
  end type p1gal
contains
  !>-------------------------------------------------------------
  !> Static constructor.
  !> (procedure public for type p1 gal
  !> Instantiate and initilize )
  !>
  !> usage:
  !>     call 'var'%init(this, lun_err, grid)
  !>
  !> where:
  !> \param[in] lun_err -> integer. Logic unit for error message
  !> \param[in] grid    -> type(mesh). Data of the mesh
  !<-------------------------------------------------------------
  subroutine init_p1gal(this, lun_err, grid)
    use Globals
    implicit none
    !vars
    class(p1gal),       intent(out) :: this
    integer,            intent(in ) :: lun_err
    type(mesh), target, intent(in ) :: grid
    ! local variables
    integer :: nnode,n1,ncell,nterm
    integer :: res,i
    logical :: rc
    
    this%nbase = grid%nnode
    this%ncell = grid%ncell

    this%grid => grid
    
    !local copy of the length of integer array
    !n1>max number of triangles connected to the same node
    nnode=grid%nnode
    ncell=grid%ncell
    
    this%nbase = nnode
    this%ncell  = ncell
     
    !
    ! build ia_ssr, ja_ssr and nterm_ssr for ssr format
    ! build ia_csr, ja_csr and nterm_csr for csr format
    !
    n1=20     
    call this%build_iaja_ssr(lun_err,n1)
    call this%build_iaja_csr(lun_err,n1)

    !
    ! initialization and construction of assembler for ssr storage
    !
    allocate(this%assembler_ssr(3,3,ncell),stat=res)
    if(res .ne. 0) rc = IOerr(lun_err, err_alloc, 'init_p1gal', &
         ' type p1gal member assembler_ssr',res)
    call build_assembler_ssr(nnode, ncell, this%nterm_ssr, &
         this%ia_ssr, this%ja_ssr, this%grid%topol, this%assembler_ssr)

    !
    ! initialization and construction of assembler for csr storage
    !
    allocate(this%assembler_csr(3,3,ncell),stat=res)
    if(res .ne. 0) rc = IOerr(lun_err, err_alloc, 'init_p1gal', &
         ' type p1gal member assembler_csr',res)
    call build_assembler_csr(nnode, ncell, this%nterm_csr, &
         this%ia_csr, this%ja_csr, this%grid%topol, this%assembler_csr)
 
    !
    ! initialization and construction of area_basis
    !
    call this%build_integral_fun(lun_err)
    
    !
    ! initialization and construction of
    ! coefficient a,b,c of local basis function a+bx+cy
    ! for each triangle
    call this%build_coeff(lun_err)    

  end subroutine init_p1gal

  !>-------------------------------------------------------------
  !> Static destructor.
  !> (procedure public for type p1gal)
  !> deallocate all arrays for a var of type p1gal
  !>
  !> usage:
  !>     call 'var'%kill(lun)
  !>
  !> where:
  !> \param[in] lun -> integer. I/O unit for error message output
  !>
  !<-----------------------------------------------------------
  subroutine kill_p1gal(this, lun)
    implicit none
    ! vars
    class(p1gal), intent(inout) :: this
    integer, intent(in) :: lun
    ! local vars
    integer :: res,i
    logical :: rc

    if (allocated(this%assembler_ssr)) then
       deallocate(this%assembler_ssr,stat=res)
       if (res.ne.0) rc=IOerr(lun, err_dealloc, 'kill_p1gal', &
            'dealloc fail for p1gal member assembler_ssr')
    end if

    if ( allocated(this%base_coeff) ) then
       deallocate(this%base_coeff,stat=res)
       if (res.ne.0) rc=IOerr(lun, err_dealloc, 'kill_p1gal', &
            'dealloc fail for p1gal member base_coeff')
    end if

    if (allocated(this%integral_fun)) then
       deallocate(this%integral_fun,stat=res)
       if (res.ne.0) rc=IOerr(lun, err_dealloc, 'kill_p1gal', &
            'dealloc fail for p1gal member integral_fun ')
    end if

  end subroutine kill_p1gal

  !>-------------------------------------------------------------
  !> Info procedure.
  !> (public procedure for type p1gal)
  !> Prints content of a variable of type mesh
  !> 
  !> usage:
  !>     call 'var'%info(lun)
  !>
  !> where:
  !> \param[in] lun -> integer. I/O unit for error message output
  !>
  !<-------------------------------------------------------------
  subroutine write_p1gal(this, lun)
    use Globals
    implicit none
    class(p1gal), intent(in) :: this
    integer :: lun
    !
    integer :: nnode, ncell
    integer :: inode, icell,j
    write(lun,*) ' Info: p1gal structure infromation:'
    nnode=this%grid%nnode
    ncell=this%grid%ncell

1000 format(4i12)
    write(lun,*) ' Pointer assembler'
    write(lun,*) ' Number of tetrahedron'
    write(lun,*) &
         ' assembler(1,1,icell),assembler(1,2,icell),'//&
         'assembler(1,3,icell), assembler(1,4,icell)'
    write(lun,*) &
         ' assembler(2,1,icell),assembler(2,2,icell),'//&
         'assembler(2,3,icell), assembler(2,4,icell)'
    write(lun,*) &
         ' assembler(3,1,icell),assembler(3,2,icell),'//&
         'assembler(3,3,icell), assembler(3,4,icell)'
    write(lun,*) &
         ' assembler(4,1,icell),assembler(4,2,icell),'//&
         'assembler(4,3,icell), assembler(4,4,icell)'

    do icell=1,ncell
       write(lun,*) ' Tetrahedron',icell
       write(lun,1000) &
            this%assembler_ssr(1,1,icell), this%assembler_ssr(1,2,icell),&
            this%assembler_ssr(1,3,icell), this%assembler_ssr(1,4,icell)
       write(lun,1000) &
            this%assembler_ssr(2,1,icell), this%assembler_ssr(2,2,icell),&
            this%assembler_ssr(2,3,icell), this%assembler_ssr(2,4,icell)
       write(lun,1000) &
            this%assembler_ssr(3,1,icell), this%assembler_ssr(3,2,icell),&
            this%assembler_ssr(3,3,icell), this%assembler_ssr(3,4,icell)
       write(lun,1000) &
            this%assembler_ssr(4,1,icell), this%assembler_ssr(4,2,icell),&
            this%assembler_ssr(4,3,icell), this%assembler_ssr(4,4,icell)
    end do
    write(lun,*) ' '

    write(lun,*) ' Coefficients of the P1 basis function a+bx+cy+dz'
    write(lun,*) ' Number of tetrahedron'
    write(lun,*) ' a_v1 b_v1 c_v1 d_v1 '
    write(lun,*) ' a_v2 b_v2 c_v2 d_v2 '
    write(lun,*) ' a_v3 b_v3 c_v3 d_v3 '
    write(lun,*) ' a_v4 b_v4 c_v4 d_v4 '
1010 format(4(1pe12.4))
    do icell=1,ncell
       write(lun,*) ' Tetrahedron',icell
       do j=1,this%grid%nnodeincell
          write(lun,1010) this%base_coeff(j,:,icell)
       end do
    end do
    write(lun,*) ' '

    write(lun,*) 'Volume related to each node'
    do inode = 1,nnode
       write(lun,*) ' Node',inode,'integral',this%integral_fun(inode)
    end do
    write(lun,*) ' '

  end subroutine write_p1gal


  !>-------------------------------------------------------------
  !> Part of the static constructor.
  !> (procedure private for type p1gal member coeff_a, coeff_b,
  !> coeff_c, coeff_d
  !> used in init. Follows 
  !> http://www.math.unipd.it/~putti/teaching/metodi-mat/
  !>               esercitazione/esercitazione-fem.pdf
  !> Allocate and build array coeff_a, coeff_b, coeff_c, coeff_d)
  !>
  !> usage:
  !>     call var%build_coeff(lun_err, grid)
  !>
  !> where:
  !> \param[in ] lun_err -> integer. Logic unit for error message
  !<-------------------------------------------------------------
  ! TODO rewrite computation of coefficients with the solution
  ! of the linear system 
  ! ( 1 x1 y1 z1 ) a_i = (1 0 0 0 )
  ! ( 1 x2 y2 z2 ) b_i = (0 1 0 0 )
  ! ( 1 x3 y3 z3 ) c_i = (0 0 1 0 )
  ! ( 1 x4 y4 z4 ) d_i = (0 0 0 1 )
  subroutine build_coeff(this, lun_err)
    use Globals
    implicit none
    class(p1gal), intent (inout) :: this
    integer, intent(in) :: lun_err
    ! local variables
    integer res
    integer ncell,nnodeincell
    integer icell, inodeloc,i,j,k,inode,inode2
    integer :: ipiv(4), info
    real(kind=double) :: xl(3),yl(3),zl(3),t3loc(3),gradf(3),Hf(3,3)
    real(kind=double) :: local_mat(4,4), local_b(4)
    logical rc

    ncell       = this%grid%ncell
    nnodeincell = this%grid%nnodeincell
    
    allocate(&
         this%base_coeff(4,3,ncell),&
         this%grad_projected(3,3,ncell),&
         stat=res)
    if(res .ne. 0) rc = IOerr(lun_err, err_alloc , 'build coeff',&
         'type p1gal member base_coeff grad_projected',res)
    
    do icell=1,ncell
       do inodeloc=1,nnodeincell
          ! nodal coordinates
          xl(inodeloc)=this%grid%coord(1,this%grid%topol(inodeloc,icell))
          yl(inodeloc)=this%grid%coord(2,this%grid%topol(inodeloc,icell))
          zl(inodeloc)=this%grid%coord(3,this%grid%topol(inodeloc,icell))
       end do
       
       do inodeloc=1,nnodeincell
      
          ! reference frame vectors at the nodes
          select case (this%grid%normal_storage)
          case('node')
             t3loc = this%grid%normal_node(:,inode)
          case('cell')
             t3loc = this%grid%normal_cell(:,icell)
          end select

          ! set the rhs of the local system
          local_b = zero
          local_b(inodeloc) = one

          ! set the matrix of the local system
          local_mat = zero
          local_mat(:,1) = one
          local_mat(1:3,2) = xl
          local_mat(1:3,3) = yl 
          local_mat(1:3,4) = zl
          local_mat(4,2) = xl(inodeloc)+t3loc(1)
          local_mat(4,3) = yl(inodeloc)+t3loc(2)
          local_mat(4,4) = zl(inodeloc)+t3loc(3)
          ! solve the local system
          call DGETRF(4, 4, local_mat, 4, ipiv, info )
          call DGETRS('N', 4, 1, local_mat, 4, ipiv, local_b,&
               4, info)

!!$          this%coeff_a(inodeloc,icell) = local_b(1)
!!$          this%coeff_b(inodeloc,icell) = local_b(2)
!!$          this%coeff_c(inodeloc,icell) = local_b(3)
!!$          this%coeff_d(inodeloc,icell) = local_b(4)
          
          this%base_coeff(:,inodeloc,icell) = local_b(:)

          call tan_proj(t3loc, &
               this%base_coeff(2:4,inodeloc,icell),&
               this%grad_projected(1:3,inodeloc,icell))
          
          !write(*,*) icell, inodeloc,info
          
          !write(*,*) t3loc
          !write(*,*) this%base_coeff(2:4,inodeloc,icell)
          !write(*,*) this%grad_projected(1:3,inodeloc,icell)
       end do

    end do
  
  end subroutine build_coeff

  
   !>-------------------------------------------------------------
  !> Procedure for build of stiffness matrix
  !> $S(i,j)=\int_{\Domain} \Grad \Psi_i \Grad \Psi_j$
  !> (procedure private for type p1gal)
  !> The format of the produced stiffness matrix can be in ssr or csr
  !> If the flag in_place is present and it is equal to 1
  !> the subroutine works directly on the input matrix
  !> that must be properly allocate for ssr system
  !>
  !> usage:
  !>     call 'var'%(stiff,lun_err,imem,[in_place])
  !>
  !> where:
  !> \param[inout] stiff               -> spmat.   Stiff matrix
  !> \param[in   ] imem                -> integer. Storage system used
  !> \param[in   ] lun_err             -> integer. I/O unit err. msg.
  !> \param[in   ] (optional) in_place -> integer. Optional flag 
  !>                                      in_place .eq. 1 => Work directly
  !>                                            on matrix stiff in input
  !>                                      otherwise => Work on local array
  !>                                          and then copy
  !<-------------------------------------------------------------
  subroutine build_stiff(this, lun_err, storage_system, cond, stiff)
    use Globals
    use SparseMatrix
    implicit none
    class(p1gal),      intent(in   ) :: this
    integer,           intent(in   ) :: lun_err
    character(len=3),  intent(in   ) :: storage_system
    real(kind=double), intent(in   ) :: cond(this%grid%ncell)
    type(spmat),       intent(inout) :: stiff
    ! local
    logical     :: rc 
    integer     :: nbase,nterm
    
    nbase= this%nbase

    if ( storage_system .eq. 'ssr' ) nterm=this%nterm_ssr
    if ( storage_system .eq. 'csr' ) nterm=this%nterm_csr

    if ( .not. stiff%is_initialized ) then
       call stiff%init(lun_err, &
            nbase,nbase,nterm,&
            storage_system,dim_kernel=1,&
            is_symmetric=.true.) 
    else
       ! check if passed matrix has been initilized properly
       if ( .not. stiff%check(&
            nbase,nbase,nterm,&
            storage_system=storage_system,&
            dim_kernel=1,is_symmetric=.true.) ) then
          rc = IOerr(lun_err, err_val, 'build_stiff', &
               ' Matrix Stiff passed has not the proper dimension')
       end if
    end if

     if ( storage_system .eq. 'ssr' ) call assembly_stiff_ssr(this,cond,stiff)
     if ( storage_system .eq. 'csr' ) call assembly_stiff_csr(this,cond,stiff)

  contains
    ! Assembly procedure for stiff matrix in ssr format
    subroutine assembly_stiff_ssr(this,cond,stiff)
      use Globals
      use SparseMatrix
      implicit none
      class(p1gal),      intent(in   ) :: this
      real(kind=double), intent(in   ) :: cond(this%grid%ncell)
      type(spmat),       intent(inout) :: stiff
      ! local variables
      integer :: icell,i,j,ind
      integer :: nnodeincell,ndim
      real(kind=double) :: gradbase(3),gradtest(3)
      real(kind=double) :: ddot

      nnodeincell = this%grid%nnodeincell
      ndim        = this%grid%ndim

      !
      ! assign ia and ja
      !
      stiff%ia = this%ia_ssr
      stiff%ja = this%ja_ssr

      !
      ! assembly coefff
      !
      stiff%coeff = zero
      !
      do icell=1,this%grid%ncell
         do j = 1,nnodeincell
            !
            ! get coefficient of the gradeint of the local base fucntions
            !
            call this%get_gradbase(j,icell,gradbase)
            do i = j,nnodeincell
               !
               ! get coefficient of the gradeint of the local test fucntions
               !
               call this%get_gradbase(i,icell,gradtest)
               ind = this%assembler_ssr(i,j,icell)
               stiff%coeff(ind) = stiff%coeff(ind) + &
                    cond(icell) * ddot(ndim,gradbase,1,gradtest,1) * &
                    this%grid%size_cell(icell)
            end do
         end do
      end do
      
      !
      ! assign kernel
      !
      stiff%kernel = one
    end subroutine assembly_stiff_ssr

    ! Assembly procedure for stiff matrix in csr format
    subroutine assembly_stiff_csr(this,cond,stiff)
      use Globals
      use SparseMatrix
      implicit none
      class(p1gal),      intent(in   ) :: this
      real(kind=double), intent(in   ) :: cond(this%grid%ncell)
      type(spmat),       intent(inout) :: stiff
      ! local variables
      integer :: icell,i,j,ind
      integer :: nnodeincell,ndim
      real(kind=double) :: gradbase(3),gradtest(3)
      real(kind=double) :: ddot

      nnodeincell = this%grid%nnodeincell
      ndim        = this%grid%ndim

      !
      ! assign ia and ja
      !
      stiff%ia = this%ia_csr
      stiff%ja = this%ja_csr

      !
      ! assembly coefff
      !
      stiff%coeff = zero
      !
      do icell=1,this%grid%ncell
         do j = 1,nnodeincell
            !
            ! get coefficient of the gradeint of the local base fucntions
            !
            call this%get_gradbase(j,icell,gradbase)
            do i = 1,nnodeincell
               !
               ! get coefficient of the gradeint of the local test fucntions
               !
               call this%get_gradbase(i,icell,gradtest)
               ind = this%assembler_csr(i,j,icell)
               stiff%coeff(ind) = stiff%coeff(ind) + &
                    cond(icell) * ddot(ndim,gradbase,1,gradtest,1) *&
                    this%grid%size_cell(icell)
            end do
         end do
      end do
      
      !
      ! assign kernel
      !
      stiff%kernel = one
    end subroutine assembly_stiff_csr
    
  end subroutine build_stiff

  !>-------------------------------------------------------------
  !> Procedure for evaluation of gradient over a triangle
  !> of function in $P1(\Tau(\Omega))$
  !> (procedure public for type p1gal member grad_x, grad_y)
  !>
  !> usage:
  !>     call "var"%eval_grad(this,icell,pot,grad)
  !>
  !> where:
  !> \param[in] icell  -> integer. Cell index 
  !> \param[in] pot    -> real dimension(nnodeincell) 
  !>                        Coeff. of $u_h\in P1_h$ on cell
  !> \param[in] grad   -> real dimension(3). 
  !>                         grad(u_h) $u_h\in P1_h$ on cell
  !<-------------------------------------------------------------
  subroutine eval_gradcell(this,icell,pot,grad)
    use Globals
    implicit none
    class(p1gal),      intent(in ) :: this
    integer,           intent(in ) :: icell
    real(kind=double), intent(in ) :: pot(this%grid%nnodeincell)
    real(kind=double), intent(out) :: grad(3)
    !local array
    integer :: iloc, i
    real(kind=double) :: ddot
    real(kind=double) :: potnode
    real(kind=double) :: gradbase(3)
    
    grad = zero
    do iloc = 1, this%grid%nnodeincell
       call this%get_gradbase(iloc,icell,gradbase)
       do i = 1,this%grid%ndim
          grad(i) = grad(i) + pot(iloc) * gradbase(i)
       end do
    end do

  end subroutine eval_gradcell


  !>-------------------------------------------------------------
  !> Procedure for evaluation of gradient over a triangle
  !> of function in $P1(\Tau(\Omega))$
  !> (procedure public for type p1gal member grad_x, grad_y)
  !>
  !> usage:
  !>     call eval_grad(this,pot,grad)
  !>
  !> where:
  !> \param[in] pot    -> real array. Coeff. of   $u_h\in P1_h$
  !> \param[in] grad   -> real dimension= (3,ncell). 
  !>                      grad(u_h) $u_h\in P1_h$
  !<-------------------------------------------------------------
  subroutine eval_grad(this,pot,grad)
    use Globals
    implicit none
    class(p1gal),      intent(in ) :: this
    real(kind=double), intent(in ) :: pot(this%nbase)
    real(kind=double), intent(out) :: grad(3,this%ncell)
    !local array
    integer :: icell
    integer :: nnodeincell
    
    
    nnodeincell = this%grid%nnodeincell

    do icell=1,this%ncell
       !u(x,y)_{|T_{icell}}=\sum_{i=1,3}u_i (a_i + b_i x + c_i y)

       ! grad_x_{|T_{icell}}=\sum_{i=1,3}u_i b_{i}
       call  this%eval_gradcell(icell,&
            pot(this%grid%topol(1:nnodeincell,icell)),&
            grad(:,icell) )
       
    end do
  end subroutine eval_grad

  !>-------------------------------------------------------------
  !> Procedure for evaluation of euclidean norm of
  !> the gradient over a triangle
  !> of function in $P1(\Tau(\Omega))$
  !> (procedure public for type p1gal)
  !>
  !> usage:
  !>     call eval_norm_grad(this,pot,nrm_grad)
  !>
  !> where:
  !> \param[in] pot       -> real array. Coeff. of $u_h$
  !> \param[in] nrm_grad -> real array. \sqrt(grad_x(u_h)^2+grad_y(u_h)^2)
  !<-------------------------------------------------------------

  subroutine eval_nrm_grad(this,pot,nrm_grad)
    use Globals
    implicit none
    class(p1gal),      intent(in   ) :: this
    real(kind=double), intent(in   ) :: pot(this%nbase)
    real(kind=double), intent(inout) :: nrm_grad(this%ncell)
    !local array
    !
    integer :: icell
    integer :: ndim, nnodeincell
    real(kind=double) :: gradcell(3)
    real(kind=double) :: dnrm2
    
    nnodeincell = this%grid%nnodeincell
    ndim        = this%grid%ndim

    do icell=1, this%grid%ncell
       ! u(x,y,z)_{|T_{icell}}=
       ! \sum_{i=1,nnodeincell} u_i (a_i + b_i*x + c_i*y+d_i*z)

       ! grad_{|T_{icell}}= 
       ! \sum_{i=1,nnodeincell} u_i (b_{i},c_{i},d_{i})
       

       call  this%eval_gradcell(icell,&
            pot(this%grid%topol(1:nnodeincell,icell)),&
            gradcell)

       nrm_grad(icell) = dnrm2(ndim,gradcell,1) 

    end do
  end subroutine eval_nrm_grad

  

  !>-------------------------------------------------------------
  !> Part of the static constructor
  !> (procedure private for type p1gal, used in init): 
  !> Construction of integer pointer IA, JA
  !> nterm_ssr = number of non-zero element for sparse matrix with 
  !> symmetric SSR storage. 
  !>
  !> usage:
  !>     call "var"%build_iaja_ssr(lun_err,N1)
  !>
  !> where:
  !> \param[in ] lun_err -> integer. Logic unit for error message   
  !> \param[in ] N1      -> integer : Number bigger than the maximum
  !>                        number of triangles in node. 
  !>                        Defined in init_p1gal, generally 20  
  !<-------------------------------------------------------------
  subroutine build_iaja_ssr(this,lun_err,N1)
    use Globals
    implicit none
    class(p1gal), intent(inout) :: this
    integer,      intent(in   ) :: lun_err
    integer,      intent(in   ) :: N1
    ! local 
    logical :: rc
    integer :: res
    integer :: i
    integer :: nbase,ncell,nterm,nterm_max
    integer, allocatable :: ja_tmp(:)
    
    !
    ! set dimensions
    !
    nbase=this%grid%nnode
    ncell=this%grid%ncell
    nterm_max=nbase*N1
    
    !
    ! allocate member ia
    !
    allocate(this%ia_ssr(nbase+1),stat=res)
    if(res .ne. 0) rc = IOerr(lun_err, err_alloc , 'build_iaja_ssr',&
         'type p1gal member ia',res)
    

    !
    ! allocate work array ja_temp
    !
    allocate(ja_tmp(nterm_max),stat=res)
    if(res .ne. 0) rc = IOerr(lun_err, err_alloc , 'build_iaja_ssr',&
         'work array ja_tmp',res)

    call build_iajatmp(lun_err,nbase,ncell,N1,nterm_max,nterm,&
         this%grid%topol,this%ia_ssr,ja_tmp)

    this%nterm_ssr = nterm

    !
    ! allocate work array ja_temp
    !
    allocate(this%ja_ssr(nterm),stat=res)
    if(res .ne. 0) rc = IOerr(lun_err, err_alloc , 'build_iaja_ssr',&
         'type p1gal member ja',res)
    
    do i=1,nterm
       this%ja_ssr(i)=ja_tmp(i)
    end do

    !
    ! free memory
    !
    deallocate(ja_tmp,stat=res)
    if(res .ne. 0) rc = IOerr(lun_err, err_dealloc , 'build iaja',&
         'work array ja_tmp',res)
    
  contains  
    !
    ! 
    ! Construction of integer pointer IA, JA_TMP and evaluation of 
    ! nterm_ssr = number of non-zero element for sparse matrix with 
    ! symmetric CSR storage. JA_TMP contains a tail of zeros 
    !  from element JA_TMP(NTERM+1))
    !
    ! usage:
    !     call build_iajatmp(lun_err,N,NE,N1,MAXTERM,NTERM,TRIANG,IA,JA_TMP)
    !
    ! where:
    ! \param[in ] lun_err -> integer. Logic unit for error message   
    ! \param[in ] N       -> integer : Number of nodes   
    ! \param[in ] NE      -> integer : Number of triangles
    ! \param[in ] N1      -> integer : Number bigger than the maximum
    !                        number of triangles in node. 
    !                        Defined in init_p1gal, generally 20  
    ! \param[in ] MAXTERM -> integer : Size of JA_TMP, generally N1*N
    ! \param[out] NTERM   -> integer : Size of ja
    ! \param[in ] TRIANG  -> integer(4,ncell) : Nodes in triangle + material
    ! \param[out] IA      -> integer(N+1) : Pointer of diagonal element
    ! \param[out] JA_TMP  -> integer(4,ncell) : Pointer to column index of 
    !                        nonzero element, with a tail of zeros    
    subroutine build_iajatmp(lun_err,N,NE,N1,MAXTERM,NTERM,TRIANG,IA,JA_TMP)
      implicit none
      integer, intent(in ) :: lun_err
      integer, intent(in ) :: N,N1,NE,MAXTERM
      integer, intent(out) :: NTERM
      integer, intent(in ) :: TRIANG(4,NE)
      integer, intent(out) :: IA(N+1),JA_TMP(MAXTERM)
      ! Local variable
      integer I,J,K,L,M,III,KK,MM,MCONTR
      integer I1(3)
      logical continua,rc

      !
      ! construction of IA E JA_TMP
      !
      
      !
      ! fix diagonal elements with step N1
      !        
      JA_TMP=0
      JA_TMP(1)=1
      do k=1,maxterm,n1
         ja_tmp(k)=k/n1+1
      end do
      !
      !  analyze all triangle ( ncell )
      !
      do K=1,NE
         do I=1,3
            I1(I)=TRIANG(I,K)
         end do
         !
         !  order nodes in increasing order 
         !
         do i=1,2
            do j=i+1,3
               if (I1(i) .gt. I1(j)) then
                  kk=I1(j)
                  I1(j)=I1(i)
                  I1(i)=kk
               end if
            end do
         end do
         !
         !  
         !  build JA_TMP
         !
         do I=1,2
            J=I+1
            do L=J,3
               M=N1*(I1(I)-1)+L-J+2
               MCONTR=N1*I1(I)
               continua=.false.
               do while (&
                    ( ((I1(L)-JA_TMP(M)).lt.0).or.&
                    ((I1(L)-JA_TMP(M)).gt.0)) .and. &
                    (.not.continua) ) 
                  if ((I1(L)-JA_TMP(M)).gt.0) then
                     IF(JA_TMP(M).EQ.0) then
                        JA_TMP(M)=I1(L)
                        continua=.true.
                     else
                        M=M+1
                        if (M-MCONTR.GE.0) then
                           III=MCONTR/N1
                           WRITE(lun_err,101)III,K
                           rc = IOerr(lun_err, err_val, 'build_iajatmp', &
                                ' N1 < max number triangles in node, N1=', N1)
                        else
                           continua=.false.
                        end if
                     end if
                  elseif ((I1(L)-JA_TMP(M)).lt.0) then
                     mm=m
                     mm=mm+1
                     if (M-MCONTR.GE.0) then
                        III=MCONTR/N1
                        WRITE(lun_err,101)III,K
                        rc = IOerr(lun_err, err_val, 'build_iajatmp', &
                             ' N1 < max number triangles in node, N1=', N1)
                     else
                        do while ((JA_TMP(MM).gt.0).or.(JA_TMP(MM).lt.0))
                           mm=mm+1
                           if (M-MCONTR.GE.0) then
                              III=MCONTR/N1
                              WRITE(lun_err,101)III,K
                              rc = IOerr(lun_err, err_val, 'build_iajatmp', &
                                   ' N1 < max number triangles in node, N1=', N1)
                           end if
                        end do
                        do while (JA_TMP(MM).eq.0) 
                           JA_TMP(mm)=JA_TMP(mm-1)
                           mm=mm-1
                           do while (mm.gt.m) 
                              JA_TMP(mm)=JA_TMP(mm-1)
                              mm=mm-1
                           end do
                        end do
                     end if
                     JA_TMP(m)=i1(l)
                  end if
               end do
            end do
         end do
      end do

      !
      !  build IA
      !
      IA(1)=1
      M=1
      J=1
      do K=1,MAXTERM,N1
         do I=1,N1
            if (JA_TMP(K+I-1).ne.0) then
               M=M+1
            end if
         end do
         J=J+1
         IA(J)=M
      end do
101   FORMAT(1X,'RIGA = ',I6,' TRIANGLE = ',I6,'  INCREASE N1=minimal connectivity ')

      !
      ! moving in JA_TMP all non zero elements to right and determination of NTERM
      !
      M=0
      do I=1,MAXTERM
         if (JA_TMP(I)/=0) then
            M=M+1
            JA_TMP(M)=JA_TMP(I)
         end if
      end do
      !
      NTERM=M
    end subroutine build_iajatmp
  end subroutine build_iaja_ssr


  !>-------------------------------------------------------------
  !> Part of the static constructor
  !> (procedure private for type p1gal member assembler, used in init:
  !> allocation and construction)
  !>
  !> usage:
  !>     call build_assembler_ssr(lun_err, nnode, ncell, nterm, ia ,ja, triang, assembler)
  !>
  !> where:
  !> \param[in ] nnode   -> integer. Number of Nodes
  !> \param[in ] ncell   -> integer. Number of triangles
  !> \param[in ] nterm   -> integer. Number of non-zero element
  !> \param[in ] ia      -> integer(N+1) : Pointer of diagonal element
  !> \param[in ] ja      -> integer(nterm) : Pointer to column index of 
  !> \param[in ] triang  -> integer(4,ncell) :Nodes in triangle + material 
  !> \par-ma[out] assembler   -> integer(3,3,ncell) : Pointer  
  !<-------------------------------------------------------------
  subroutine build_assembler_ssr(nnode, ncell, nterm, ia ,ja, triang, assembler)
    use Globals
    implicit none
    integer, intent(in )  :: nnode, ncell, nterm
    integer, intent(in )  :: ia(nnode+1), ja(nterm), triang(4,ncell)
    integer, intent(out) :: assembler(3,3,ncell)
    ! local variables
    integer :: icell,i,j,ii,jj,kk,ind,inode(3),start,tobefound

    ! construction of assembler
    assembler=0
    do icell=1,ncell
       do i=1,3
          inode(i)=triang(i,icell)
       end do
       do i=1,3
          ii=inode(i)
          do j=i,3
             jj=inode(j)
             start    =ii
             tobefound=jj
             if (tobefound .lt. start ) then
                ! if 
                kk        = start
                start     = tobefound
                tobefound = kk
             end if
             ind=ia(start)
             do while ( ja(ind) .ne. tobefound )
                ind=ind+1
             end do
             assembler(j,i,icell)=ind
          end do
       end do
    end do
  end subroutine build_assembler_ssr

   !>-------------------------------------------------------------
  !> Part of the static constructor
  !> (procedure private for type p1gal, used in init): 
  !> Construction of integer pointer IA, JA
  !> nterm_ssr = number of non-zero element for sparse matrix with 
  !> symmetric SSR storage. 
  !>
  !> usage:
  !>     call "var"%build_iaja_ssr(lun_err,N1)
  !>
  !> where:
  !> \param[in ] lun_err -> integer. Logic unit for error message   
  !> \param[in ] N1      -> integer : Number bigger than the maximum
  !>                        number of triangles in node. 
  !>                        Defined in init_p1gal, generally 20  
  !<-------------------------------------------------------------
  subroutine build_iaja_csr(this,lun_err,N1)
    use Globals
    implicit none
    class(p1gal), intent(inout) :: this
    integer,      intent(in   ) :: lun_err
    integer,      intent(in   ) :: N1
    ! local 
    logical :: rc
    integer :: res
    integer :: i
    integer :: nbase,ncell,nterm,nterm_max
    integer, allocatable :: ja_tmp(:)
    
    !
    ! set dimensions
    !
    nbase= this%grid%nnode
    ncell = this%grid%ncell
    nterm_max=nbase*N1
    
    !
    ! allocate member ia
    !
    allocate(this%ia_csr(nbase+1),stat=res)
    if(res .ne. 0) rc = IOerr(lun_err, err_alloc , 'build_iaja_csr',&
         'type p1gal member ia_csr',res)
    

    !
    ! allocate work array ja_temp
    !
    allocate(ja_tmp(nterm_max),stat=res)
    if(res .ne. 0) rc = IOerr(lun_err, err_alloc , 'build_iaja_csr',&
         'work array ja_tmp',res)

    call build_iajatmp_csr(lun_err,nbase,ncell,N1,nterm_max,nterm,&
         this%grid%topol,this%ia_csr,ja_tmp)

    this%nterm_csr = nterm

    !
    ! allocate work array ja_temp
    !
    allocate(this%ja_csr(nterm),stat=res)
    if(res .ne. 0) rc = IOerr(lun_err, err_alloc , 'build_iaja_csr',&
         'type p1gal member ja_csr',res)
    
    do i=1,nterm
       this%ja_csr(i)=ja_tmp(i)
    end do

    !
    ! free memory
    !
    deallocate(ja_tmp,stat=res)
    if(res .ne. 0) rc = IOerr(lun_err, err_dealloc , 'build iaja',&
         'work array ja_tmp',res)
    
  contains  
    
    
    !>-------------------------------------------------------------
    !> Part of the static constructor
    !> (procedure private for type p1gal,used in init: 
    !> Construction of integer pointer IA, JA_TMP and evaluation of 
    !> nterm_csr = number of non-zero element for sparse matrix with 
    !> CSR storage. JA_TMP containes a tail of zeros 
    !> from element JA_TMP(NTERM+1))
    !>
    !> usage:
    !>     call build_iajatmp_csr(lun_err,N,NE,N1,MAXTERM,NTERM,TRIANG,IA,JA_TMP)
    !>
    !> where:
    !> \param[in ] lun_err -> integer. Logic unit for error message   
    !> \param[in ] N       -> integer : Number of nodes   
    !> \param[in ] NE      -> integer : Number of triangles
    !> \param[in ] N1      -> integer : Number bigger than the maximum
    !>                        number of triangles in node. 
    !>                        Defined in init_p1gal, genearally 20  
    !> \param[in ] MAXTERM -> integer : Size od JA_TMP, generally N1*N
    !> \param[out] NTERM   -> integer : Size of ja
    !> \param[in ] TRIANG  -> integer(4,ncell) : Nodes in triangle + material
    !> \param[out] IA      -> integer(N+1) : Pointer of diagonal element
    !> \param[out] JA_TMP  -> integer(4,ncell) : Pointer to column index of 
    !>                        nonzero element, with a tail of zeros
    !<-------------------------------------------------------------
    subroutine build_iajatmp_csr(lun_err,N,NE,N1,MAXTERM,NTERM,TRIANG,IA,JA_TMP)
      implicit none
      integer, intent(in ) :: lun_err
      integer, intent(in ) :: N,N1,NE,MAXTERM
      integer, intent(out) :: NTERM
      integer, intent(in ) :: TRIANG(4,NE)
      integer, intent(out) :: IA(N+1),JA_TMP(MAXTERM)
      ! Local variable
      integer I,J,K,L,M,III,KK,MM,MCONTR
      integer I1(3)
      logical continua,rc

      !
      ! construction of IA E JA_TMP
      !
      ! fix diagonal elements with step N1
      !        
      !
      JA_TMP=0
      JA_TMP(1)=1
!!$    do K=1,MAXTERM-1
!!$       IF (K/N1*N1 .EQ. K) JA_TMP(K+1)=K/N1+1
!!$    end do
      do k=1,maxterm,n1
         ja_tmp(k)=k/n1+1
      end do
      !
      !  analyze all triangle ( ncell )
      !
      do K=1,NE
         do I=1,3
            I1(I)=TRIANG(I,K)
         end do
         !
         !  order nodes in increasing order 
         !
         do i=1,2 
            do j=i+1,3 
               if (I1(i) .gt. I1(j)) then
                  kk=I1(j)
                  I1(j)=I1(i)
                  I1(i)=kk
               end if
            end do
         end do
         !
         !  
         !  build JA_TMP
         !
         do I=1,3
            do L=1,3
               M=N1*(I1(I)-1)+L
               MCONTR=N1*I1(I)
               continua=.false.
               do while (&
                    ( ((I1(L)-JA_TMP(M)).lt.0).or.&
                    ((I1(L)-JA_TMP(M)).gt.0)) .and. &
                    (.not.continua) ) 
                  if ((I1(L)-JA_TMP(M)).gt.0) then
                     IF(JA_TMP(M).EQ.0) then
                        JA_TMP(M)=I1(L)
                        continua=.true.
                     else
                        M=M+1
                        if (M-MCONTR.GE.0) then
                           III=MCONTR/N1
                           WRITE(lun_err,101)III,K
                           rc = IOerr(lun_err, err_val, 'build_iajatmp', &
                                ' N1 < max number triangles in node, N1=', N1)
                        else
                           continua=.false.
                        end if
                     end if
                  elseif ((I1(L)-JA_TMP(M)).lt.0) then
                     mm=m
                     mm=mm+1
                     if (M-MCONTR.GE.0) then
                        III=MCONTR/N1
                        WRITE(lun_err,101)III,K
                        rc = IOerr(lun_err, err_val, 'build_iajatmp', &
                             ' N1 < max number triangles in node, N1=', N1)
                     else
                        do while ((JA_TMP(MM).gt.0).or.(JA_TMP(MM).lt.0))
                           mm=mm+1
                           if (M-MCONTR.GE.0) then
                              III=MCONTR/N1
                              WRITE(lun_err,101)III,K
                              rc = IOerr(lun_err, err_val, 'build_iajatmp', &
                                   ' N1 < max number triangles in node, N1=', N1)
                           end if
                        end do
                        do while (JA_TMP(MM).eq.0) 
                           JA_TMP(mm)=JA_TMP(mm-1)
                           mm=mm-1
                           do while (mm.gt.m) 
                              JA_TMP(mm)=JA_TMP(mm-1)
                              mm=mm-1
                           end do
                        end do
                     end if
                     JA_TMP(m)=I1(L)
                  end if
               end do
            end do
         end do
      end do

      !
      !  build IA
      !
      IA(1)=1
      M=1
      J=1
      do K=1,MAXTERM,N1
         do I=1,N1
            if (JA_TMP(K+I-1).ne.0) then
               M=M+1
            end if
         end do
         J=J+1
         IA(J)=M
      end do
101   FORMAT(1X,'RIGA = ',I6,' TRIANGOLO = ',I6,'  AUMENTARE N1=minimal connectivity ')


      !moving in JA_TMP all non zero elements to right and determination of NTERM
      M=0
      do I=1,MAXTERM
         if (JA_TMP(I)/=0) then
            M=M+1
            JA_TMP(M)=JA_TMP(I)
         end if
      end do
      !
      NTERM=M
    end subroutine build_iajatmp_csr

  end subroutine build_iaja_csr






  !>-------------------------------------------------------------
  !> Part of the static constructor
  !> (procedure private for type p1gal member assembler, used in init:
  !> allocation and construction)
  !>
  !> usage:
  !>     call build_assembler_csr(lun_err,nnode,ncell,nterm,ia,ja,triang,assembler)
  !>
  !> where:
  !> \param[in ] nnode   -> integer. Number of Nodes
  !> \param[in ] ncell   -> integer. Number of triangles
  !> \param[in ] nterm   -> integer. Number of non-zero element
  !> \param[in ] ia      -> integer(N+1) : Pointer of diagonal element
  !> \param[in ] ja      -> integer(nterm) : Pointer to column index of 
  !> \parma[in ] triang  -> integer(4,ncell) :Nodes in triangle + material 
  !> \parma[out] assembler   -> integer(3,3,ncell) : Pointer  
  !<-------------------------------------------------------------
  subroutine build_assembler_csr(&
       nnode, ncell, nterm, ia ,ja, triang, assembler)
    use Globals
    implicit none
    integer, intent(in ) :: nnode, ncell, nterm
    integer, intent(in ) :: ia(nnode+1), ja(nterm), triang(4,ncell)
    integer, intent(out) :: assembler(3,3,ncell)
    ! local variables
    integer :: icell,i,j,ii,jj,kk,ind,inode(3),start,tobefound

    ! construction of assembler
    assembler=0
    do icell=1,ncell
       do i=1,3
          inode(i)=triang(i,icell)
       end do
       do i=1,3
          ii=inode(i)
          do j=1,3
             jj=inode(j)
             ind=ia(ii)
             do while ( ja(ind) .ne. jj )
                ind=ind+1
             end do
             assembler(j,i,icell)=ind
          end do
       end do
    end do
  end subroutine build_assembler_csr



  !>-------------------------------------------------------------
  !> Procedure for building volume related to each node
  !> (procedure private for type p1gal member integral_fun,
  !> used in init)
  !>
  !> usage:
  !>     call 'var'build_integral_fun(lun_err, grid)
  !>
  !> where:
  !> \param[in ] lun_err -> integer. Logic unit for error message
  !> \param[in ] grid    -> type(mesh). Mesh data
  !<-------------------------------------------------------------
  subroutine build_integral_fun(this, lun_err)
    use Globals
    implicit none
    class(p1gal),      intent(inout) :: this
    integer,           intent(in   ) :: lun_err
    !local variable
    logical :: rc
    integer :: res
    integer :: inode,icell,iloc
    integer :: ncell,nnodeincell
    real(kind=double) :: basefun_on_bar

    
    allocate(this%integral_fun(this%grid%nnode),stat=res)
    if(res .ne. 0) rc = IOerr(lun_err, err_alloc, 'build_integral_fun', &
         ' type p1gal member integral_fun',res)    
    
    ncell       = this%grid%ncell
    nnodeincell = this%grid%nnodeincell
    
    basefun_on_bar = one / nnodeincell 

    this%integral_fun = zero
    do icell=1,this%grid%ncell
       do iloc=1,nnodeincell
          inode = this%grid%topol(iloc,icell)
          this%integral_fun(inode) = this%integral_fun(inode) + &
               this%grid%size_cell(icell)*basefun_on_bar
       end do
    end do
   
  end subroutine build_integral_fun

  !>-------------------------------------------------------------------
  !> Procedure for building integral of P1 basis function
  !> (procedure public for type p1gal)
  !>
  !> usage:
  !>     call 'var'%int_test(grid, data, integral)
  !>
  !> where:
  !> \param[in ] data                -> real. (Dimension=this%ncell)
  !>                                     Constant data on the tetrahedrons
  !> \param[out] integral            -> real. (Dimension=this%nbasis)
  !>                                     integral(i)=\Int_{\Domain}data\Psi_{i}
  !<-------------------------------------------------------------------
  subroutine int_test(this, data, integral)
    use Globals
    implicit none
    class(p1gal),         intent(in   ) :: this
    real(kind=double),    intent(in   ) :: data(this%ncell)
    real(kind=double),    intent(inout) :: integral(this%nbase)
    !local variable
    integer :: inode, icell, iloc, ncell, nnodeincell
    real(double) ::  basefun_on_bar
    
    ncell       = this%grid%ncell
    nnodeincell = this%grid%nnodeincell
    
    basefun_on_bar = one / nnodeincell

    integral = zero
    do icell = 1, ncell
       do iloc = 1,nnodeincell
          inode = this%grid%topol(iloc,icell)
          integral(inode) = integral(inode) + &
               data(icell)*this%grid%size_cell(icell)* basefun_on_bar
       end do
    end do
   
  end subroutine int_test

  !>-------------------------------------------------------------------
  !> Build rhs of elliptic equation given forcing and Neumann 
  !> terms
  !> (procedure public for type p1gal)
  !>
  !> usage:
  !>     call 'var'%build_rhs_forcing(forcing, rhs_forcing, neum)
  !>
  !> where:
  !> \param[in ] forcing         -> real. Forcing constant over tetrahedrons
  !> \param[in ] (optional) neum -> real. Neumann boundary conditions
  !> \param[out] rhs_forcing     -> real. Right hand side of the system
  !<-------------------------------------------------------------------
  subroutine build_rhs_forcing(this, forcing, rhs_forcing, neum)
    use Globals
    implicit none
    class(p1gal),               intent(in   ) :: this
    real(kind=double),          intent(in   ) :: forcing(this%grid%ncell)
    real(kind=double),          intent(inout) :: rhs_forcing(this%grid%nnode)
    real(kind=double),optional, intent(in   ) :: neum(this%grid%nedge_bc)
    !local 
    integer :: inode, icell, iedge, iloc

    rhs_forcing = zero 
    
    call this%int_test(forcing, rhs_forcing)
    
    ! add neumman contribution, if present
    if (present (neum) ) then
       do iedge = 1,this%grid%nedge_bc
          ! node on grid
          do iloc=1,this%grid%nnodeincell
             ! note iside_face has been reordered, the first
             ! nface_bc faces are the ones of the boundary
             inode = this%grid%iside(iloc,iedge)
             rhs_forcing(inode) = rhs_forcing(inode) - neum(iedge)
          end do
       end do
    else
       ! there are not Neumann boundary condiotions
    end if

  end subroutine build_rhs_forcing

  !>-------------------------------------------------------------
  !> Procedure for evaluation of gradient over a triangle
  !> of function in $P1(\Tau(\Omega))$
  !> (procedure public for type p1gal member grad_x, grad_y)
  !>
  !> usage:
  !>     call "var"%eval_grad(this,icell,pot,grad)
  !>
  !> where:
  !> \param[in] icell  -> integer. Cell index 
  !> \param[in] pot    -> real dimension(nnodeincell) 
  !>                        Coeff. of $u_h\in P1_h$ on cell
  !> \param[in] grad   -> real dimension(3). 
  !>                         grad(u_h) $u_h\in P1_h$ on cell
  !<-------------------------------------------------------------
  subroutine get_gradbase(this,iloc,icell,grad_base)
    use Globals
    implicit none
    class(p1gal),      intent(in ) :: this
    integer,           intent(in ) :: iloc
    integer,           intent(in ) :: icell
    real(kind=double), intent(out) :: grad_base(3)
    !local array
    integer :: i
    real(kind=double) :: ddot
    real(kind=double) :: potnode
    
    grad_base(:) = this%grad_projected(:,iloc,icell)
        
  end subroutine get_gradbase

  
  !>-------------------------------------------------------------
  !> Static constructor.
  !> (procedure public for type p1 gal
  !> Instantiate and initialize )
  !>
  !> usage:
  !>     call 'var'%init(this, lun_err, grid)
  !>
  !> where:
  !> \param[in] lun_err -> integer. Logic unit for error message
  !> \param[in] grid    -> type(mesh). Data of the triangulation
  !<-------------------------------------------------------------
  subroutine genrcm(this, lun_err, lun_out, grid, perm, inv_perm)
    use Globals
    use SparseMatrix
    implicit none
    !vars
    class(p1gal),intent(inout) :: this
    integer,     intent(in   ) :: lun_err
    integer,     intent(in   ) :: lun_out
    type(mesh),  intent(inout) :: grid
    integer,     intent(inout) :: perm(grid%nnode)
    integer,     intent(inout) :: inv_perm(grid%nnode)

    ! local variables
    logical :: rc
    integer :: res
    integer :: nnode,n1,ncell,i
    type(spmat) :: adj_matrix
    
    !
    ! The adj. matrix of the p1-Galerkin used to
    ! build the rcm permutation is
    ! the connectivity of the triagulation
    ! without the diagonal terms
    !
    call grid%nodenode_connection(lun_err,.False.,adj_matrix)
        
    call adj_matrix%genrcm(lun_err,perm,inv_perm)

    call adj_matrix%kill(lun_err)
    
  end subroutine genrcm

end module P1GalerkinSurface






